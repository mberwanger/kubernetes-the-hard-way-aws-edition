# Provisioning Compute Resources

Kubernetes requires a set of machines to host the Kubernetes control plane and the worker nodes where containers are ultimately run. In this lab you will provision the compute resources required for running a secure and highly available Kubernetes cluster across a single [availability  zone](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html).

> Ensure a default compute zone and region have been set as described in the [Prerequisites](01-prerequisites.md#set-a-default-compute-region-and-zone) lab.

## Networking

The Kubernetes [networking model](https://kubernetes.io/docs/concepts/cluster-administration/networking/#kubernetes-model) assumes a flat network in which containers and nodes can communicate with each other. In cases where this is not desired [network policies](https://kubernetes.io/docs/concepts/services-networking/network-policies/) can limit how groups of containers are allowed to communicate with each other and external network endpoints.

> Setting up network policies is out of scope for this tutorial.

### Virtual Private Cloud Network

In this section a dedicated [Virtual Private Cloud](https://docs.aws.amazon.com/AmazonVPC/latest/GettingStartedGuide/getting-started-ipv4.html) (VPC) network will be setup to host the Kubernetes cluster.

Create the `kubernetes-the-hard-way` VPC:

```
VPC_ID=$(aws ec2 create-vpc \
  --cidr-block 10.240.0.0/16 | jq -r '.Vpc.VpcId')
```

```
aws ec2 create-tags \
  --resources ${VPC_ID} \
  --tags 'Key=Name,Value=kubernetes-the-hard-way'
```

```
aws ec2 modify-vpc-attribute \
  --enable-dns-support \
  --vpc-id ${VPC_ID}
```

```
aws ec2 modify-vpc-attribute \
  --enable-dns-hostnames \
  --vpc-id ${VPC_ID}
```

A [subnet](https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Subnets.html) must be provisioned with an IP address range large enough to assign a private IP address to each node in the Kubernetes cluster.

Create a subnet:

```
SUBNET_ID=$(aws ec2 create-subnet \
  --vpc-id ${VPC_ID} \
  --cidr-block 10.240.0.0/24 | jq -r '.Subnet.SubnetId')
```

```
aws ec2 create-tags \
  --resources ${SUBNET_ID} \
  --tags 'Key=Name,Value=kubernetes-the-hard-way'
```

> The `10.240.0.0/24` IP address range can host up to 254 compute instances.

Create an internet gateway and attach it to the `kubernetes-the-hard-way` VPC:

```
INTERNET_GATEWAY_ID=$(aws ec2 create-internet-gateway | jq -r '.InternetGateway.InternetGatewayId')
```

```
aws ec2 create-tags \
  --resources ${INTERNET_GATEWAY_ID} \
  --tags 'Key=Name,Value=kubernetes-the-hard-way'
```

```
aws ec2 attach-internet-gateway \
  --vpc-id ${VPC_ID} \
  --internet-gateway-id ${INTERNET_GATEWAY_ID}
```

Create a route in the route table that points all traffic (0.0.0.0/0) to the Internet gateway:

```
ROUTE_TABLE_ID=$(aws ec2 describe-route-tables \
  --output text \
  --filters "Name=vpc-id,Values=${VPC_ID}" \
  --query 'RouteTables[*].Associations[*].RouteTableId')
```

```
aws ec2 create-tags \
  --resources ${ROUTE_TABLE_ID} \
  --tags 'Key=Name,Value=kubernetes-the-hard-way'
```

```
aws ec2 create-route \
  --route-table-id ${ROUTE_TABLE_ID} \
  --destination-cidr-block 0.0.0.0/0 \
  --gateway-id ${INTERNET_GATEWAY_ID}
```

Associate route table with the `kubernetes-the-hard-way` subnet:

```
aws ec2 associate-route-table \
  --subnet-id ${SUBNET_ID} \
  --route-table-id ${ROUTE_TABLE_ID}
```

Modify the public IP addressing behavior of your subnet so that an instance launched into the subnet automatically receives a public IP address:

```
aws ec2 modify-subnet-attribute \
  --subnet-id ${SUBNET_ID} \
  --map-public-ip-on-launch
```

### Security Groups

A security group was generated by default during the creation of the `kubernetes-the-hard-way` vpc, which allows internal communication across all protocols. You will need to retrieve the security group id and store it for later use in this tutorial.

```
INT_SECURITY_GROUP_ID=$(aws ec2 describe-security-groups \
  --output text \
  --filters "Name=vpc-id,Values=${VPC_ID}" \
  --query 'SecurityGroups[*].GroupId')
```

Create a security group that allows external SSH, ICMP, and HTTPS:

```
EXT_SECURITY_GROUP_ID=$(aws ec2 create-security-group \
  --group-name kubernetes-the-hard-way-allow-external \
  --description "Allows external SSH, ICMP, and HTTPS" \
  --vpc-id ${VPC_ID} | jq -r '.GroupId')
```

```
aws ec2 authorize-security-group-ingress \
  --group-id ${EXT_SECURITY_GROUP_ID} \
  --ip-permissions '[ {"IpProtocol": "tcp", "FromPort": 22, "ToPort": 22, "IpRanges": [{"CidrIp": "0.0.0.0/0"}]}, {"IpProtocol": "tcp", "FromPort": 6443, "ToPort": 6443, "IpRanges": [{"CidrIp": "0.0.0.0/0"}]}, {"IpProtocol": "icmp", "FromPort": -1, "ToPort": -1, "IpRanges": [{"CidrIp": "0.0.0.0/0"}]} ]'
```

> An [elastic load balancer](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/introduction.html) will be used to expose the Kubernetes API Servers to remote clients.

### Kubernetes Public IP Address

Allocate a static IP address that will be attached to the external load balancer fronting the Kubernetes API Servers:

```
ELASTIC_IP=$(aws ec2 allocate-address \
  --domain vpc | jq -r '.AllocationId')
```

```
aws ec2 create-tags \
  --resources ${ELASTIC_IP} \
  --tags 'Key=Name,Value=kubernetes-the-hard-way'
```

Verify the `kubernetes-the-hard-way` static IP address was created in your default compute region:

```
aws ec2 describe-addresses \
  --output table \
  --filters '{"Name":"tag:Name", "Values":["kubernetes-the-hard-way"]}'
```

> output

```
----------------------------------------------------
|                 DescribeAddresses                |
+--------------------------------------------------+
||                    Addresses                   ||
|+--------------------+---------+-----------------+|
||    AllocationId    | Domain  |    PublicIp     ||
|+--------------------+---------+-----------------+|
||  eipalloc-XXXXXXXX |  vpc    |  XX.XXX.XX.XXX  ||
|+--------------------+---------+-----------------+|
|||                     Tags                     |||
||+---------+------------------------------------+||
|||   Key   |               Value                |||
||+---------+------------------------------------+||
|||  Name   |  kubernetes-the-hard-way           |||
||+---------+------------------------------------+||
```

### Create Frontend Load Balancer

Create an external load balancer fronting the Kubernetes API Servers:

```
LOAD_BALANCER_ARN=$(aws elbv2 create-load-balancer \
  --name kubernetes-the-hard-way \
  --type network \
  --subnet-mappings "SubnetId=${SUBNET_ID},AllocationId=${ELASTIC_IP}" | jq -r '.LoadBalancers[].LoadBalancerArn')
```

```
TARGET_GROUP_ARN=$(aws elbv2 create-target-group \
  --name kubernetes-targets \
  --protocol TCP \
  --port 6443 \
  --vpc-id ${VPC_ID} | jq -r '.TargetGroups[].TargetGroupArn')
```

```
aws elbv2 create-listener \
  --load-balancer-arn ${LOAD_BALANCER_ARN} \
  --protocol TCP --port 6443 \
  --default-actions Type=forward,TargetGroupArn=${TARGET_GROUP_ARN}
```

Verify the `kubernetes-the-hard-way` elastic load balancer was created in your default compute region:

```
aws elbv2 describe-load-balancers \
  --output table \
  --names kubernetes-the-hard-way \
  --query "LoadBalancers[*].{Name:LoadBalancerName,Scheme:Scheme,State:State.Code,Public_IP:AvailabilityZones[*].LoadBalancerAddresses[*].IpAddress,Zone:AvailabilityZones[*].ZoneName}"
```

> output

```
----------------------------------------------------------
|                  DescribeLoadBalancers                 |
+--------------------------+-------------------+---------+
|           Name           |      Scheme       |  State  |
+--------------------------+-------------------+---------+
|  kubernetes-the-hard-way |  internet-facing  |  active |
+--------------------------+-------------------+---------+
||                       Public_IP                      ||
|+------------------------------------------------------+|
||  XX.XXX.XX.XXX                                       ||
|+------------------------------------------------------+|
||                         Zone                         ||
|+------------------------------------------------------+|
||  us-east-1b                                          ||
|+------------------------------------------------------+|
```

## Compute Instances

The compute instances in this lab will be provisioned using [Ubuntu Server](https://www.ubuntu.com/server) 16.04, which has good support for the [cri-containerd container runtime](https://github.com/containerd/cri-containerd). Each compute instance will be provisioned with a fixed private IP address to simplify the Kubernetes bootstrapping process.

### Kubernetes Controllers

Create three compute instances which will host the Kubernetes control plane:

```
for i in 0 1 2; do
  INSTANCE_ID=$(aws ec2 run-instances \
    --image-id ami-66506c1c \
    --count 1 \
    --instance-type t2.small \
    --key-name kubernetes-the-hard-way \
    --subnet-id ${SUBNET_ID} \
    --user-data "INSTANCE_NAME=controller-${i}\n" \
    --private-ip-address 10.240.0.1${i} \
    --security-group-ids ${EXT_SECURITY_GROUP_ID} ${INT_SECURITY_GROUP_ID} \
    --block-device-mapping "[ { \"DeviceName\": \"/dev/sda1\", \"Ebs\": { \"VolumeSize\": 200 } } ]" \
    --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=controller-$i}]" | jq -r '.Instances[].InstanceId')

  aws ec2 modify-instance-attribute \
    --instance-id ${INSTANCE_ID} \
    --no-source-dest-check    
done
```

### Kubernetes Workers

Each worker instance requires a pod subnet allocation from the Kubernetes cluster CIDR range. The pod subnet allocation will be used to configure container networking in a later exercise. The `pod-cidr` instance metadata will be used to expose pod subnet allocations to compute instances at runtime.

> The Kubernetes cluster CIDR range is defined by the Controller Manager's `--cluster-cidr` flag. In this tutorial the cluster CIDR range will be set to `10.200.0.0/16`, which supports 254 subnets.

Create three compute instances which will host the Kubernetes worker nodes:

```
for i in 0 1 2; do
  INSTANCE_ID=$(aws ec2 run-instances \
    --image-id ami-66506c1c \
    --count 1 \
    --instance-type t2.small \
    --key-name kubernetes-the-hard-way \
    --subnet-id ${SUBNET_ID} \
    --user-data "INSTANCE_NAME=worker-${i}\nPOD_CIDR=10.200.${i}.0/24\n" \
    --private-ip-address 10.240.0.2${i} \
    --security-group-ids ${EXT_SECURITY_GROUP_ID} ${INT_SECURITY_GROUP_ID} \
    --block-device-mapping "[ { \"DeviceName\": \"/dev/sda1\", \"Ebs\": { \"VolumeSize\": 200 } } ]" \
    --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=worker-$i}]" | jq -r '.Instances[].InstanceId')

  aws ec2 modify-instance-attribute \
    --instance-id ${INSTANCE_ID} \
    --no-source-dest-check    
done
```

### Verification

List the compute instances in your `kubernetes-the-hard-way` VPC:

```
aws ec2 describe-instances \
  --output table \
  --filters "Name=vpc-id,Values=${VPC_ID}" \
  --query "Reservations[*].Instances[*].{Zone:Placement.AvailabilityZone,Instance_Type:InstanceType,Private_IP:PrivateIpAddress,Public_IP:PublicIpAddress,Status:State.Name,Name:Tags[?Key=='Name']|[0].Value}"
```

> output

```
---------------------------------------------------------------------------------------------
|                                     DescribeInstances                                     |
+---------------+---------------+--------------+-----------------+-----------+--------------+
| Instance_Type |     Name      | Private_IP   |    Public_IP    |  Status   |    Zone      |
+---------------+---------------+--------------+-----------------+-----------+--------------+
|  t2.small     |  worker-2     |  10.240.0.22 |  XX.XXX.XXX.XXX |  running  |  us-east-1a  |
|  t2.small     |  worker-1     |  10.240.0.21 |  XX.XXX.XXX.XX  |  running  |  us-east-1a  |
|  t2.small     |  controller-1 |  10.240.0.11 |  XX.XXX.XX.XXX  |  running  |  us-east-1a  |
|  t2.small     |  controller-2 |  10.240.0.12 |  XX.X.XXX.XX    |  running  |  us-east-1a  |
|  t2.small     |  controller-0 |  10.240.0.10 |  XX.XXX.XXX.XXX |  running  |  us-east-1a  |
|  t2.small     |  worker-0     |  10.240.0.20 |  XX.XXX.XX.XX   |  running  |  us-east-1a  |
+---------------+---------------+--------------+-----------------+-----------+--------------+
```

Next: [Provisioning a CA and Generating TLS Certificates](04-certificate-authority.md)
